# Тестування на підробку міжсайтових запитів

## Резюме
Міжсайтова підробка запитів (CSRF) — це атака, яка змушує кінцевого користувача виконувати ненавмисні дії у веб-програмі, у якій він наразі пройшов автентифікацію. За допомогою соціальної інженерії (наприклад, надіславши посилання електронною поштою чи чатом) зловмисник може змусити користувачів веб-програми виконати дії за вибором зловмисника. Успішний експлойт CSRF може скомпрометувати дані кінцевого користувача та роботу, якщо він спрямований на звичайного користувача. Якщо цільовим кінцевим користувачем є обліковий запис адміністратора, атака CSRF може скомпрометувати всю веб-програму.

CSRF покладається на:

1) Поведінка веб-браузера щодо обробки інформації, пов’язаної із сеансом, наприклад файлів cookie та інформації автентифікації HTTP.
2) Знання зловмисника про дійсні URL-адреси веб-додатків, запити або функції.
3) Управління сеансом програми покладається лише на інформацію, відому браузеру.
4) Наявність тегів HTML, наявність яких викликає негайний доступ до ресурсу HTTP[S]; наприклад, тег зображення img.

Пункти 1, 2 і 3 необхідні для наявності вразливості, тоді як пункт 4 полегшує фактичне використання, але не є суворо обов’язковим.

1) Браузери автоматично надсилають інформацію, яка використовується для ідентифікації сеансу користувача. Припустімо, що сайт — це сайт, на якому розміщено веб-додаток, а користувач-жертва щойно пройшов автентифікацію на сайті. У відповідь сайт надсилає жертві файл cookie, який ідентифікує запити, надіслані жертвою, як належні до автентифікованого сеансу жертви. Щойно браузер отримає файл cookie, встановлений сайтом, він автоматично надішле його разом із будь-якими подальшими запитами, спрямованими на сайт.
2) Якщо програма не використовує пов’язану із сеансом інформацію в URL-адресах, тоді URL-адреси програми, їхні параметри та допустимі значення можуть бути ідентифіковані. Це можна зробити за допомогою аналізу коду або доступу до програми та врахування форм і URL-адрес, вбудованих у HTML або JavaScript.
3) «Відомий веб-переглядачу» означає таку інформацію, як файли cookie або інформацію автентифікації на основі HTTP (наприклад, базову автентифікацію, а не автентифікацію на основі форми), яка зберігається браузером і згодом відображається під час кожного запиту, спрямованого до області програми, що запитує це аутентифікація. Уразливості, які обговорюються далі, стосуються додатків, які повністю покладаються на цю інформацію для ідентифікації сеансу користувача.

Для простоти розгляньте URL-адреси, доступні GET (хоча обговорення також стосується запитів POST). Якщо жертва вже пройшла автентифікацію, надсилання іншого запиту призведе до автоматичного надсилання файлу cookie разом із ним. На малюнку нижче показано, як користувач отримує доступ до програми на www.example.com.

![image](https://user-images.githubusercontent.com/41470575/204098028-e310c168-0260-4fa3-8e97-277ce0c628e0.png)

Запит GET може бути надісланий користувачем кількома різними способами:

* Використання веб-додатку
* Введення URL-адреси безпосередньо в браузері
* Перехід за зовнішнім посиланням, яке вказує на URL-адресу

Ці виклики не відрізняються програмою. Зокрема, третя може бути досить небезпечною. Існує ряд методів і вразливостей, які можуть приховати справжні властивості посилання. Посилання може бути вбудовано в повідомлення електронної пошти, з’являтися на шкідливому веб-сайті, на який заманюють користувача, або з’являтися у вмісті, розміщеному третьою стороною (наприклад, на іншому веб-сайті чи електронному листі HTML), і вказувати на ресурс програми. . Якщо користувач натискає посилання, оскільки він уже автентифікований веб-додатком на сайті, браузер видасть запит GET до веб-додатку, що супроводжується інформацією автентифікації (cookie ID сеансу). Це призводить до того, що над веб-програмою виконується дійсна операція, якої користувач не очікує; наприклад, переказ коштів у програмі веб-банкінгу.

Використовуючи такий тег, як img, як зазначено в пункті 4 вище, користувачеві навіть не обов’язково переходити за певним посиланням. Припустімо, що зловмисник надсилає користувачеві електронний лист, спонукаючи його відвідати URL-адресу, що посилається на сторінку, що містить наступний (надто спрощений) HTML.


> \<html> </br>
>     \<body></br>
> ...</br>
> \<img src="https://www.company.example/action" width="0" height="0"></br>
> ...</br>
>     \</body></br>
> \</html></br>

Коли браузер відображає цю сторінку, він також намагатиметься відобразити вказане зображення нульового розміру (тому невидиме) із https://www.company.example. Це призводить до того, що запит автоматично надсилається до веб-додатку, розміщеного на сайті. Неважливо, щоб URL-адреса зображення не посилалася на належне зображення, оскільки його наявність у будь-якому випадку ініціює дію запиту, указану в полі src. Це відбувається за умови, що завантаження зображень не вимкнено в браузері. У більшості веб-переглядачів не вимкнуто завантаження зображень, оскільки це призвело б до того, що більшість веб-програм не буде зручно використовувати.

Проблема тут є наслідком:

HTML-теги на сторінці, що призводять до автоматичного виконання HTTP-запиту (img є одним із них).
Браузер не може визначити, що ресурс, на який посилається img, не є легітимним зображенням.
Завантаження зображення, яке відбувається незалежно від розташування передбачуваного джерела зображення, тобто форма та саме зображення не обов’язково повинні бути розташовані на одному хості чи навіть на одному домені.
Той факт, що HTML-контент, не пов’язаний із веб-додатком, може стосуватися компонентів у додатку, а також той факт, що браузер автоматично створює дійсний запит до додатка, уможливлює такий вид атаки. Немає способу заборонити таку поведінку, якщо зловмисник не зможе взаємодіяти з функціями програми.

В інтегрованому середовищі пошти/браузера просте відображення повідомлення електронної пошти, що містить посилання на зображення, призведе до виконання запиту до веб-програми з пов’язаним файлом cookie браузера. Повідомлення електронної пошти можуть посилатися на начебто дійсні URL-адреси зображень, наприклад:

<img src="https://[нападник]/picture.gif" width="0" height="0">
У цьому прикладі [зловмисник] – це сайт, контрольований зловмисником. Використовуючи механізм перенаправлення, зловмисний сайт може використовувати http://[attacker]/picture.gif, щоб спрямувати жертву на http://[thirdparty]/action і ініціювати дію.

Файли cookie — не єдиний приклад такої вразливості. Веб-додатки, інформацію про сеанси яких повністю надає браузер, також уразливі. Це включає програми, які покладаються лише на механізми автентифікації HTTP, оскільки інформація автентифікації відома браузеру та надсилається автоматично після кожного запиту. Це не включає автентифікацію на основі форми, яка відбувається лише один раз і генерує певну форму інформації, пов’язаної із сеансом, зазвичай файл cookie.

Припустімо, що жертва увійшла до веб-консолі керування брандмауером. Щоб увійти, користувач має пройти автентифікацію, а інформація про сеанс зберігається у файлі cookie.

Припустімо, веб-консоль керування брандмауером має функцію, яка дозволяє автентифікованому користувачеві видаляти правило, визначене його числовим ідентифікатором, або всі правила в конфігурації, якщо користувач вказує * (насправді небезпечна функція, але така, що створює більш цікавий приклад). Далі буде показано сторінку видалення. Припустімо, що форма – для простоти – надсилає запит GET. Щоб видалити правило номер один:

https://[target]/fwmgt/delete?rule=1
Щоб видалити всі правила:

https://[target]/fwmgt/delete?rule=*

![image](https://user-images.githubusercontent.com/41470575/204098162-aae7c152-4e46-482a-b689-5e32544a7287.png)

> https://www.company.example/fwmgt/delete?rule=*

![image](https://user-images.githubusercontent.com/41470575/204098172-73f3d2c2-0bae-455a-9dae-dca786b21ffa.png)

Або перейшовши за посиланням, яке вказує, безпосередньо чи через переспрямування, на наведену вище URL-адресу. Або, знову ж таки, за допомогою доступу до HTML-сторінки з вбудованим тегом img, що вказує на ту саму URL-адресу.

У всіх цих випадках, якщо користувач наразі ввійшов у програму керування брандмауером, запит буде виконано успішно та змінить конфігурацію брандмауера. Можна уявити атаки, націлені на конфіденційні програми та автоматичні аукціонні ставки, грошові перекази, замовлення, зміну конфігурації критичних програмних компонентів тощо.

Цікаво те, що ці вразливості можуть використовуватися за брандмауером; тобто достатньо, щоб посилання, яке атакується, було доступне жертві, а не безпосередньо зловмисникові. Зокрема, це може бути будь-який веб-сервер внутрішньої мережі; наприклад, у згаданому вище сценарії керування брандмауером, який навряд чи буде відкритим для Інтернету.

Самовразливі програми, тобто програми, які використовуються як вектор атаки, так і ціль (наприклад, програми веб-пошти), погіршують ситуацію. Оскільки користувачі входять у систему, коли читають свої електронні листи, уразлива програма такого типу може дозволити зловмисникам виконувати такі дії, як видалення повідомлень або надсилання повідомлень, які, здається, надходять від жертви.

## Цілі тесту
Визначте, чи можна ініціювати запити від імені користувача, які не ініціює користувач.

## Як тестувати
Перевірте програму, щоб переконатися, що її керування сеансами є вразливим. Якщо керування сеансом покладається лише на значення на стороні клієнта (інформація, доступна браузеру), то програма є вразливою. «Значення на стороні клієнта» стосуються файлів cookie та облікових даних автентифікації HTTP (базова автентифікація та інші форми автентифікації HTTP; не автентифікація на основі форми, яка є автентифікацією на рівні програми).

Ресурси, доступні через HTTP-запити GET, легко вразливі, хоча POST-запити можуть бути автоматизовані за допомогою JavaScript і також є вразливими; отже, використання лише POST недостатньо для виправлення появи вразливостей CSRF.

У випадку POST можна використовувати наступний зразок.

Створіть HTML-сторінку, схожу на наведену нижче
Розмістіть HTML на шкідливому або сторонньому сайті
Надішліть жертві(ам) посилання на сторінку та спонукайте їх натиснути її.
<html>
<body onload='document.CSRF.submit()'>

<form action='http://targetWebsite/Authenticate.jsp' method='POST' name='CSRF'>
    <input type='hidden' name='name' value='Hacked'>
    <input type='hidden' name='password' value='Hacked'>
</form>

</body>
</html>
У випадку веб-додатків, у яких розробники використовують JSON для зв’язку між браузером і сервером, може виникнути проблема через відсутність параметрів запиту у форматі JSON, які є обов’язковими для форм, що надсилаються самостійно. Щоб обійти цей випадок, ми можемо використати форму самостійного надсилання з корисними навантаженнями JSON, включаючи приховані введення, для використання CSRF. Нам доведеться змінити тип кодування (enctype) на text/plain, щоб забезпечити доставку корисного навантаження як є. Код експлойта буде виглядати наступним чином:

<html>
 <тіло>
  <script>history.pushState('', '', '/')</script>
   <form action='http://victimsite.com' method='POST' enctype='text/plain'>
     <input type='hidden' name='{"name":"hacked","password":"hacked","padding":"'value='something"}' />
     <input type='submit' value='Submit request' />
   </form>
 </body>
</html>
Запит POST буде таким:

POST / HTTP/1.1
Хост:victimsite.com
Тип вмісту: текстовий/звичайний

{"name":"hacked","password":"hacked","padding":"=something"}
Коли ці дані надсилаються як запит POST, сервер із задоволенням прийме поля імені та пароля та проігнорує поле з доповненням імені, оскільки воно йому не потрібно.

## Санація
Щоб дізнатися про заходи профілактики, перегляньте шпаргалку з профілактики OWASP CSRF.
